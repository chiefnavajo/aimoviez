

Plan ready to copy/paste:
# Claude Code: Page Loading & Responsiveness Optimization Plan## ObjectiveMake the dashboard page load faster and feel more responsive through comprehensive performance optimizations.## Context- Next.js 15 application with React Query- Dashboard page at `src/app/dashboard/page.tsx` (~1700 lines)- Already has dynamic imports for some heavy components- Uses framer-motion for animations- Video-heavy interface with clip voting---## Step 1: Add Resource Hints in Layout**File:** `src/app/layout.tsx`**Action:** Add resource hints before the closing `</head>` tag (or in the `<head>` section if using Next.js metadata API).**Code to add:**// In the RootLayout component, add these links:<head>  {/* Preconnect to critical domains */}  <link rel="preconnect" href="https://dxixqdmqomqzhilmdfzg.supabase.co" />  <link rel="preconnect" href="https://dxixqdmqomqzhilmdfzg.supabase.co" crossOrigin="anonymous" />  <link rel="dns-prefetch" href="https://*.pusher.com" />  <link rel="dns-prefetch" href="https://fonts.googleapis.com" />  <link rel="dns-prefetch" href="https://fonts.gstatic.com" />    {/* Preload critical font */}  <link    rel="preload"    href="/fonts/inter-var.woff2"    as="font"    type="font/woff2"    crossOrigin="anonymous"  /></head>**Note:** If using Next.js metadata API, you may need to add these via a custom `head.tsx` or use the `metadata` export with `other` property.---## Step 2: Optimize React Query Configuration**File:** `src/app/dashboard/page.tsx`**Location:** Around line 733 where `useQuery` is called**Current code:**const { data: votingData, isLoading, error, refetch } = useQuery<VotingState>({  queryKey: ['voting', 'track-main'],  queryFn: async () => {    const response = await fetch('/api/vote?trackId=track-main');    if (!response.ok) {      throw new Error('Failed to fetch voting data');    }    const apiResponse: APIVotingResponse = await response.json();    return transformAPIResponse(apiResponse);  },  staleTime: Infinity,  retry: 3,});**Replace with:**const { data: votingData, isLoading, error, refetch } = useQuery<VotingState>({  queryKey: ['voting', 'track-main'],  queryFn: async () => {    const response = await fetch('/api/vote?trackId=track-main');    if (!response.ok) {      throw new Error('Failed to fetch voting data');    }    const apiResponse: APIVotingResponse = await response.json();    return transformAPIResponse(apiResponse);  },  staleTime: Infinity,  gcTime: 5 * 60 * 1000, // Keep in cache for 5 minutes  retry: 3,  refetchOnMount: false, // Don't refetch if data exists  placeholderData: (previousData) => previousData, // Show cached data immediately});---## Step 3: Add Suspense Boundaries**File:** `src/app/dashboard/page.tsx`**Action:** Wrap heavy components in Suspense boundaries**Location 1:** Around line 1477 where MiniLeaderboard is rendered**Find:**<MiniLeaderboard  currentClipId={currentClip?.clip_id}  onClipSelect={...}  isCollapsed={leaderboardCollapsed}  onToggleCollapse={...}/>**Replace with:**<Suspense fallback={  <div className="absolute top-0 left-0 right-0 z-30 pt-12 pb-2">    <div className="h-16 bg-white/5 rounded-lg animate-pulse mx-4" />  </div>}>  <MiniLeaderboard    currentClipId={currentClip?.clip_id}    onClipSelect={...}    isCollapsed={leaderboardCollapsed}    onToggleCollapse={...}  /></Suspense>**Location 2:** Where CommentsSection is rendered (if visible)**Find:**{showComments && (  <CommentsSection ... />)}**Replace with:**{showComments && (  <Suspense fallback={    <div className="absolute right-0 top-0 bottom-0 w-80 bg-black/40 backdrop-blur-md border-l border-white/10 p-4">      <div className="space-y-4">        {[...Array(3)].map((_, i) => (          <div key={i} className="h-20 bg-white/5 rounded animate-pulse" />        ))}      </div>    </div>  }>    <CommentsSection ... />  </Suspense>)}**Add import at top:**import { Suspense } from 'react';---## Step 4: Optimize Video Loading Strategy**File:** `src/app/dashboard/page.tsx`**Location:** Around line 755-794 (video prefetching useEffect)**Current code:**useEffect(() => {  if (!votingData?.clips?.length) return;  const cache = preloadedVideosRef.current;  const clipsToPreload = [    (activeIndex + 1) % votingData.clips.length,    (activeIndex + 2) % votingData.clips.length,  ];  // ... rest of code}, [activeIndex, votingData?.clips]);**Replace with:**useEffect(() => {  if (!votingData?.clips?.length) return;  const cache = preloadedVideosRef.current;  // Only preload next 1 clip (reduce from 2)  const clipsToPreload = [    (activeIndex + 1) % votingData.clips.length,  ];  // Get clip IDs that should be preloaded  const preloadClipIds = new Set<string>();  clipsToPreload.forEach((index) => {    const clip = votingData.clips[index];    if (clip?.clip_id && clip?.video_url) {      preloadClipIds.add(clip.clip_id);      // Only create video element if not already cached      if (!cache.has(clip.clip_id)) {        const video = document.createElement('video');        video.preload = 'metadata'; // Changed from 'auto' to 'metadata'        video.muted = true;        video.playsInline = true;        video.src = clip.video_url;        video.load();        cache.set(clip.clip_id, video);      }    }  });  // Cleanup videos that are no longer in preload set  cache.forEach((video, clipId) => {    if (!preloadClipIds.has(clipId)) {      video.src = '';      video.load();      cache.delete(clipId);    }  });}, [activeIndex, votingData?.clips]);**Location:** Around line 1446 where video element is rendered**Find:**<video  ref={videoRef}  key={currentClip.clip_id}  src={currentClip.video_url ?? '/placeholder-video.mp4'}  poster={currentClip.thumbnail_url}  // ... other props/>**Add:**<video  ref={videoRef}  key={currentClip.clip_id}  src={currentClip.video_url ?? '/placeholder-video.mp4'}  poster={currentClip.thumbnail_url}  preload={activeIndex === 0 ? 'auto' : 'metadata'} // Only auto-load first video  loading="lazy"  // ... other props/>---## Step 5: Optimize Framer Motion Imports**File:** `src/app/dashboard/page.tsx`**Location:** Top of file, around line 20**Current:**import { motion, AnimatePresence } from 'framer-motion';**Better approach:** Keep framer-motion import but ensure it's tree-shaken properly. The real optimization is to lazy load the components that use it heavily.---## Step 6: Add useMemo for Expensive Computations**File:** `src/app/dashboard/page.tsx`**Location 1:** Around line 748 (currentClip)**Verify it's already memoized:**const currentClip = useMemo(() => votingData?.clips?.[activeIndex], [votingData?.clips, activeIndex]);**If not, add it.****Location 2:** Add memoization for clip list transformations**Find where clips are filtered/sorted and add useMemo:**x// If there's any filtering/sorting, memoize it:const sortedClips = useMemo(() => {  if (!votingData?.clips) return [];  return [...votingData.clips].sort((a, b) =>     (b.weighted_score || 0) - (a.weighted_score || 0)  );}, [votingData?.clips]);**Location 3:** Memoize vote button color calculations (if not already done)**Check PowerVoteButton component - the `getVoteColors` function should be memoized:**const colors = useMemo(() => getVoteColors(), [currentVoteType]);---## Step 7: Optimize Image Loading**File:** `src/app/dashboard/page.tsx` and related components**Location:** Find Image components**For first visible thumbnail (around line where currentClip thumbnail is shown):****Find:**<Image  src={currentClip.thumbnail_url}  // ... other props/>**Add:**<Image  src={currentClip.thumbnail_url}  priority={activeIndex === 0} // Only first image gets priority  loading={activeIndex === 0 ? 'eager' : 'lazy'}  fetchPriority={activeIndex === 0 ? 'high' : 'auto'}  // ... other props/>**For off-screen images (in leaderboard, etc.):****Find Image components in MiniLeaderboard or other lists:**<Image  src={avatar_url}  loading="lazy"  // ... other props/>---## Step 8: Reduce Bundle Size - Lazy Load Heavy Components**File:** `src/app/dashboard/page.tsx`**Location:** Top of file, around line 30**Find:**import OnboardingTour, { useOnboarding } from '@/components/OnboardingTour';**Replace with:**sx// Lazy load OnboardingTour componentconst OnboardingTour = dynamic(() => import('@/components/OnboardingTour').then(mod => mod.default), {  ssr: false,  loading: () => null,});// Keep hook import as-is (hooks can't be dynamically imported)import { useOnboarding } from '@/components/OnboardingTour';**Location:** Around line 21 (Toaster)**Find:**import { toast, Toaster } from 'react-hot-toast';**Replace with:**import { toast } from 'react-hot-toast';// Lazy load Toasterconst Toaster = dynamic(() => import('react-hot-toast').then(mod => mod.Toaster), {  ssr: false,});**Then find where Toaster is rendered and wrap in Suspense:**<Suspense fallback={null}>  <Toaster ... /></Suspense>---## Step 9: Optimize API Route Response**File:** `src/app/api/vote/route.ts`**Location:** In the GET handler, before returning response**Find the return statement:**return NextResponse.json(responseData);**Replace with:**const response = NextResponse.json(responseData);// Add caching headersresponse.headers.set('Cache-Control', 'public, s-maxage=30, stale-while-revalidate=60');response.headers.set('X-Content-Type-Options', 'nosniff');// Add ETag for conditional requestsconst etag = `"${Buffer.from(JSON.stringify(responseData)).toString('base64').slice(0, 27)}"`;response.headers.set('ETag', etag);return response;**Also add compression (if not already enabled in Next.js config):**Check `next.config.ts` - compression should be automatic in Next.js, but verify.---## Step 10: Add Prefetching for Navigation**File:** `src/app/dashboard/page.tsx`**Location:** Where Link components are used (NavButton component)**Find:**<Link href={href} aria-label={`Navigate to ${label}`}>  {content}</Link>**Add prefetch:**<Link href={href} aria-label={`Navigate to ${label}`} prefetch={true}>  {content}</Link>**Location:** Add prefetch for API routes when user is near end of list**Add useEffect:**// Prefetch next page when user is near enduseEffect(() => {  if (!votingData?.clips) return;    const isNearEnd = activeIndex >= votingData.clips.length - 2;  if (isNearEnd) {    // Prefetch next batch (if pagination exists)    // Or prefetch related data    const link = document.createElement('link');    link.rel = 'prefetch';    link.href = '/api/vote?trackId=track-main';    document.head.appendChild(link);  }}, [activeIndex, votingData?.clips]);---## Step 11: Optimize Providers Configuration**File:** `src/app/providers.tsx`**Location:** Around line 11-18**Current:**const [queryClient] = useState(() => new QueryClient({  defaultOptions: {    queries: {      staleTime: 60 * 1000, // 1 minute      refetchOnWindowFocus: false,    },  },}));**Replace with:**xconst [queryClient] = useState(() => new QueryClient({  defaultOptions: {    queries: {      staleTime: 60 * 1000, // 1 minute      gcTime: 5 * 60 * 1000, // 5 minutes (formerly cacheTime)      refetchOnWindowFocus: false,      refetchOnMount: false, // Don't refetch if data exists      retry: 1, // Reduce retries for faster failure    },    mutations: {      retry: 1,    },  },}));---## Step 12: Add Performance Monitoring (Optional)**File:** `src/app/dashboard/page.tsx`**Location:** Add useEffect at top of VotingArena component**Add:**// Performance monitoring (development only)useEffect(() => {  if (process.env.NODE_ENV === 'development') {    const perfData = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;    if (perfData) {      console.log('Performance Metrics:', {        domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,        loadComplete: perfData.loadEventEnd - perfData.loadEventStart,        firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime,      });    }  }}, []);---## Testing ChecklistAfter implementing:1. **Lighthouse Test:**   - Run Lighthouse in Chrome DevTools   - Target: Performance score > 90   - Check First Contentful Paint < 1.5s   - Check Time to Interactive < 3s2. **Network Test:**   - Open DevTools Network tab   - Check initial bundle size reduction   - Verify resource hints are working (check Timing tab)3. **Functionality Test:**   - Verify videos still play correctly   - Check voting still works   - Test navigation between clips   - Verify Suspense boundaries don't break UI4. **Performance Test:**   - Test on slow 3G throttling   - Check React DevTools Profiler for re-renders   - Verify useMemo is preventing unnecessary recalculations---## Expected Results- **Initial Load:** 30-40% faster (from ~3-4s to ~2-2.5s)- **Bundle Size:** 15-20% reduction (~100-150KB)- **Time to Interactive:** 25-35% improvement- **Perceived Performance:** Much better with Suspense and placeholder data- **Lighthouse Score:** Should improve by 10-15 points---## Notes- Test each change incrementally- Keep backups before major changes- Monitor error logs after deployment- Some optimizations may need A/B testing
Note: If using Next.js metadata API, you may need to add these via a custom head.tsx or use the metadata export with other property.
Step 2: Optimize React Query Configuration
File: src/app/dashboard/page.tsx
Location: Around line 733 where useQuery is called
Current code:
const { data: votingData, isLoading, error, refetch } = useQuery<VotingState>({  queryKey: ['voting', 'track-main'],  queryFn: async () => {    const response = await fetch('/api/vote?trackId=track-main');    if (!response.ok) {      throw new Error('Failed to fetch voting data');    }    const apiResponse: APIVotingResponse = await response.json();    return transformAPIResponse(apiResponse);  },  staleTime: Infinity,  retry: 3,});
Replace with:
const { data: votingData, isLoading, error, refetch } = useQuery<VotingState>({  queryKey: ['voting', 'track-main'],  queryFn: async () => {    const response = await fetch('/api/vote?trackId=track-main');    if (!response.ok) {      throw new Error('Failed to fetch voting data');    }    const apiResponse: APIVotingResponse = await response.json();    return transformAPIResponse(apiResponse);  },  staleTime: Infinity,  gcTime: 5 * 60 * 1000, // Keep in cache for 5 minutes  retry: 3,  refetchOnMount: false, // Don't refetch if data exists  placeholderData: (previousData) => previousData, // Show cached data immediately});
Step 3: Add Suspense Boundaries
File: src/app/dashboard/page.tsx
Action: Wrap heavy components in Suspense boundaries
Location 1: Around line 1477 where MiniLeaderboard is rendered
Find:
<MiniLeaderboard  currentClipId={currentClip?.clip_id}  onClipSelect={...}  isCollapsed={leaderboardCollapsed}  onToggleCollapse={...}/>
Replace with:
<Suspense fallback={  <div className="absolute top-0 left-0 right-0 z-30 pt-12 pb-2">    <div className="h-16 bg-white/5 rounded-lg animate-pulse mx-4" />  </div>}>  <MiniLeaderboard    currentClipId={currentClip?.clip_id}    onClipSelect={...}    isCollapsed={leaderboardCollapsed}    onToggleCollapse={...}  /></Suspense>
Location 2: Where CommentsSection is rendered (if visible)
Find:
{showComments && (  <CommentsSection ... />)}
Replace with:
{showComments && (  <Suspense fallback={    <div className="absolute right-0 top-0 bottom-0 w-80 bg-black/40 backdrop-blur-md border-l border-white/10 p-4">      <div className="space-y-4">        {[...Array(3)].map((_, i) => (          <div key={i} className="h-20 bg-white/5 rounded animate-pulse" />        ))}      </div>    </div>  }>    <CommentsSection ... />  </Suspense>)}
Add import at top:
import { Suspense } from 'react';
Step 4: Optimize Video Loading Strategy
File: src/app/dashboard/page.tsx
Location: Around line 755-794 (video prefetching useEffect)
Current code:
useEffect(() => {  if (!votingData?.clips?.length) return;  const cache = preloadedVideosRef.current;  const clipsToPreload = [    (activeIndex + 1) % votingData.clips.length,    (activeIndex + 2) % votingData.clips.length,  ];  // ... rest of code}, [activeIndex, votingData?.clips]);
Replace with:
useEffect(() => {  if (!votingData?.clips?.length) return;  const cache = preloadedVideosRef.current;  // Only preload next 1 clip (reduce from 2)  const clipsToPreload = [    (activeIndex + 1) % votingData.clips.length,  ];  // Get clip IDs that should be preloaded  const preloadClipIds = new Set<string>();  clipsToPreload.forEach((index) => {    const clip = votingData.clips[index];    if (clip?.clip_id && clip?.video_url) {      preloadClipIds.add(clip.clip_id);      // Only create video element if not already cached      if (!cache.has(clip.clip_id)) {        const video = document.createElement('video');        video.preload = 'metadata'; // Changed from 'auto' to 'metadata'        video.muted = true;        video.playsInline = true;        video.src = clip.video_url;        video.load();        cache.set(clip.clip_id, video);      }    }  });  // Cleanup videos that are no longer in preload set  cache.forEach((video, clipId) => {    if (!preloadClipIds.has(clipId)) {      video.src = '';      video.load();      cache.delete(clipId);    }  });}, [activeIndex, votingData?.clips]);
Location: Around line 1446 where video element is rendered
Find:
<video  ref={videoRef}  key={currentClip.clip_id}  src={currentClip.video_url ?? '/placeholder-video.mp4'}  poster={currentClip.thumbnail_url}  // ... other props/>
Add:
<video  ref={videoRef}  key={currentClip.clip_id}  src={currentClip.video_url ?? '/placeholder-video.mp4'}  poster={currentClip.thumbnail_url}  preload={activeIndex === 0 ? 'auto' : 'metadata'} // Only auto-load first video  loading="lazy"  // ... other props/>
Step 5: Optimize Framer Motion Imports
File: src/app/dashboard/page.tsx
Location: Top of file, around line 20
Current:
import { motion, AnimatePresence } from 'framer-motion';
Better approach: Keep framer-motion import but ensure it's tree-shaken properly. The real optimization is to lazy load the components that use it heavily.
Step 6: Add useMemo for Expensive Computations
File: src/app/dashboard/page.tsx
Location 1: Around line 748 (currentClip)
Verify it's already memoized:
const currentClip = useMemo(() => votingData?.clips?.[activeIndex], [votingData?.clips, activeIndex]);
If not, add it.
Location 2: Add memoization for clip list transformations
Find where clips are filtered/sorted and add useMemo:
// If there's any filtering/sorting, memoize it:const sortedClips = useMemo(() => {  if (!votingData?.clips) return [];  return [...votingData.clips].sort((a, b) =>     (b.weighted_score || 0) - (a.weighted_score || 0)  );}, [votingData?.clips]);
Location 3: Memoize vote button color calculations (if not already done)
Check PowerVoteButton component - the getVoteColors function should be memoized:
const colors = useMemo(() => getVoteColors(), [currentVoteType]);
Step 7: Optimize Image Loading
File: src/app/dashboard/page.tsx and related components
Location: Find Image components
For first visible thumbnail (around line where currentClip thumbnail is shown):
Find:
<Image  src={currentClip.thumbnail_url}  // ... other props/>
Add:
<Image  src={currentClip.thumbnail_url}  priority={activeIndex === 0} // Only first image gets priority  loading={activeIndex === 0 ? 'eager' : 'lazy'}  fetchPriority={activeIndex === 0 ? 'high' : 'auto'}  // ... other props/>
For off-screen images (in leaderboard, etc.):
Find Image components in MiniLeaderboard or other lists:
<Image  src={avatar_url}  loading="lazy"  // ... other props/>
Step 8: Reduce Bundle Size - Lazy Load Heavy Components
File: src/app/dashboard/page.tsx
Location: Top of file, around line 30
Find:
;
import OnboardingTour, { useOnboarding } from '@/components/OnboardingTour';
Replace with:
// Lazy load OnboardingTour componentconst OnboardingTour = dynamic(() => import('@/components/OnboardingTour').then(mod => mod.default), {  ssr: false,  loading: () => null,});// Keep hook import as-is (hooks can't be dynamically imported)import { useOnboarding } from '@/components/OnboardingTour';
Location: Around line 21 (Toaster)
Find:
import { toast, Toaster } from 'react-hot-toast';
Replace with:
import { toast } from 'react-hot-toast';// Lazy load Toasterconst Toaster = dynamic(() => import('react-hot-toast').then(mod => mod.Toaster), {  ssr: false,});
Then find where Toaster is rendered and wrap in Suspense:
>
<Suspense fallback={null}>  <Toaster ... /></Suspense>
Step 9: Optimize API Route Response
File: src/app/api/vote/route.ts
Location: In the GET handler, before returning response
Find the return statement:
return NextResponse.json(responseData);
Replace with:
const response = NextResponse.json(responseData);// Add caching headersresponse.headers.set('Cache-Control', 'public, s-maxage=30, stale-while-revalidate=60');response.headers.set('X-Content-Type-Options', 'nosniff');// Add ETag for conditional requestsconst etag = `"${Buffer.from(JSON.stringify(responseData)).toString('base64').slice(0, 27)}"`;response.headers.set('ETag', etag);return response;
Also add compression (if not already enabled in Next.js config):
Check next.config.ts - compression should be automatic in Next.js, but verify.
Step 10: Add Prefetching for Navigation
File: src/app/dashboard/page.tsx
Location: Where Link components are used (NavButton component)
Find:
<Link href={href} aria-label={`Navigate to ${label}`}>  {content}</Link>
Add prefetch:
<Link href={href} aria-label={`Navigate to ${label}`} prefetch={true}>  {content}</Link>
Location: Add prefetch for API routes when user is near end of list
Add useEffect:
// Prefetch next page when user is near enduseEffect(() => {  if (!votingData?.clips) return;    const isNearEnd = activeIndex >= votingData.clips.length - 2;  if (isNearEnd) {    // Prefetch next batch (if pagination exists)    // Or prefetch related data    const link = document.createElement('link');    link.rel = 'prefetch';    link.href = '/api/vote?trackId=track-main';    document.head.appendChild(link);  }}, [activeIndex, votingData?.clips]);
Step 11: Optimize Providers Configuration
File: src/app/providers.tsx
Location: Around line 11-18
Current:
const [queryClient] = useState(() => new QueryClient({  defaultOptions: {    queries: {      staleTime: 60 * 1000, // 1 minute      refetchOnWindowFocus: false,    },  },}));
Replace with:
const [queryClient] = useState(() => new QueryClient({  defaultOptions: {    queries: {      staleTime: 60 * 1000, // 1 minute      gcTime: 5 * 60 * 1000, // 5 minutes (formerly cacheTime)      refetchOnWindowFocus: false,      refetchOnMount: false, // Don't refetch if data exists      retry: 1, // Reduce retries for faster failure    },    mutations: {      retry: 1,    },  },}));
Step 12: Add Performance Monitoring (Optional)
File: src/app/dashboard/page.tsx
Location: Add useEffect at top of VotingArena component
Add:
// Performance monitoring (development only)useEffect(() => {  if (process.env.NODE_ENV === 'development') {    const perfData = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;    if (perfData) {      console.log('Performance Metrics:', {        domContentLoaded: perfData.domContentLoadedEventEnd - perfData.domContentLoadedEventStart,        loadComplete: perfData.loadEventEnd - perfData.loadEventStart,        firstPaint: performance.getEntriesByName('first-paint')[0]?.startTime,      });    }  }}, []);
Testing Checklist
After implementing:
Lighthouse Test:
Run Lighthouse in Chrome DevTools
Target: Performance score > 90
Check First Contentful Paint < 1.5s
Check Time to Interactive < 3s
Network Test:
Open DevTools Network tab
Check initial bundle size reduction
Verify resource hints are working (check Timing tab)
Functionality Test:
Verify videos still play correctly
Check voting still works
Test navigation between clips
Verify Suspense boundaries don't break UI
Performance Test:
Test on slow 3G throttling
Check React DevTools Profiler for re-renders
Verify useMemo is preventing unnecessary recalculations
Expected Results
Initial Load: 30-40% faster (from ~3-4s to ~2-2.5s)
Bundle Size: 15-20% reduction (~100-150KB)
Time to Interactive: 25-35% improvement
Perceived Performance: Much better with Suspense and placeholder data
Lighthouse Score: Should improve by 10-15 points
Notes
Test each change incrementally
Keep backups before major changes
Monitor error logs after deployment
Some optimizations may need A/B testing
